<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CLASSMATE AI</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    :root {
      --bg-primary: #ffffff;            /* Main background */
      --bg-secondary: #f5f5f5;          /* Sidebar/Header/Footer background */
      --bg-tertiary: #eaeaea;           /* Chat bubbles or tertiary areas */
      --text-primary: #1a1a1a;          /* Main text color */
      --text-secondary: #555555;        /* Secondary text */
      --accent-primary: #1543ce;        /* Primary accent (e.g., buttons) */
      --accent-secondary: #350071;      /* Secondary accent (e.g., hover or action) */
      --border-color: #cccccc;          /* Border and outlines */
      --font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      --border-radius: 8px;
      --sidebar-width: 280px;
      --sidebar-width-collapsed: 0px;
      --header-height: 60px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-family);
      background-color: var(--bg-primary);
      color: var(--text-primary);
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .app-container {
      display: flex;
      width: 100%;
      height: 100%;
    }

    .sidebar {
      width: var(--sidebar-width);
      background-color: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      padding: 1rem;
      transition: width 0.3s ease, padding 0.3s ease, left 0.3s ease, opacity 0.3s ease;
      overflow-x: hidden; 
      opacity: 1;
      z-index: 1010; /* Ensure sidebar is above other content */
    }
    .sidebar.collapsed {
        width: var(--sidebar-width-collapsed);
        padding: 1rem 0;
        border-right: none;
        opacity: 0;
        pointer-events: none; /* Prevent interaction when hidden */
    }

    .sidebar-header {
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .sidebar-header h2 {
      font-size: 1.2rem;
      color: var(--text-primary);
      white-space: nowrap;
    }
    .sidebar-toggle-btn {
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0;
      margin-left: 8px;
    }
    .new-chat-btn {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        background-color: var(--accent-primary);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        cursor: pointer;
        font-size: 0.9rem;
        width: 100%;
        margin-bottom: 1rem;
        transition: background-color 0.2s;
        white-space: nowrap;
    }
    .new-chat-btn:hover {
        background-color: #313030;
    }
    .chat-history-list {
        flex-grow: 1;
        overflow-y: auto;
        list-style: none;
        white-space: nowrap;
    }
    .chat-history-list li {
        padding: 0.6rem 0.5rem;
        margin-bottom: 0.5rem;
        border-radius: calc(var(--border-radius) / 2);
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 5px;
    }
    .chat-history-list li:hover {
        background-color: var(--bg-tertiary);
    }
    .chat-history-list li.active {
        background-color: var(--accent-primary);
        color: white;
    }
    .chat-history-list .chat-item-title {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .chat-history-list .chat-item-actions button {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 0.9rem;
        padding: 2px 4px;
    }
    .chat-history-list li.active .chat-item-actions button {
        color: white;
    }
    .chat-history-list .delete-chat-btn:hover {
        color: #ff4d4d;
    }
    .chat-history-list .rename-chat-btn:hover {
        color: var(--accent-secondary);
    }
    
    /* Sidebar Navigation Links */
    .sidebar-nav {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-color);
    }
    .sidebar-nav h3 {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    .sidebar-nav ul {
        list-style: none;
    }
    .sidebar-nav li a {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.6rem 0.5rem;
        text-decoration: none;
        color: var(--text-primary);
        border-radius: calc(var(--border-radius) / 2);
        transition: background-color 0.2s, color 0.2s;
        font-size: 0.95rem;
    }
    .sidebar-nav li a:hover {
        background-color: var(--bg-tertiary);
        color: var(--accent-primary);
    }
    .sidebar-nav li a i {
        width: 20px; /* Fixed width for icons */
        text-align: center;
        color: var(--text-secondary);
    }
    .sidebar-nav li a:hover i {
        color: var(--accent-primary);
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden; 
      background-color: var(--bg-primary);
      transition: margin-left 0.3s ease;
      position: relative; /* Ensure proper stacking context */
      z-index: 1000; /* Lower than sidebar but higher than other elements */
    }

    .app-container.sidebar-hidden .main-content {
        margin-left: 0;
    }

    header {
      height: var(--header-height);
      padding: 0 1.5rem;
            background: linear-gradient(
                to right,
                #0d2b8c 0%,    /* Darker Blue */
                #1543ce 20%,   /* Base Blue #1543ce */
                #000000 40%,   /* Black Center Start */
                #000000 60%,   /* Black Center End */
              #1543ce 80%,   /* Base Blue #1543ce */
              #0d2b8c 100%   /* Darker Blue */
            );
            margin-bottom: 10px; /* Changed to black as requested */
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between; /* Changed to space-between for better alignment */
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text-primary);
      flex-shrink: 0;
      position: relative; /* For proper positioning of elements */
    }
    
    .header-left {
      display: flex;
      align-items: center;
    }
    
    .header-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .header-logo {
      height: 40px; /* Adjust based on your header height */
      max-width: 100%;
      display: block;
    }
    
    .header-right {
      display: flex;
      align-items: center;
    }
    
    .header-sidebar-toggle-btn, .menu-toggle {
        background: none;
        border: none;
        color: #ffffff; /* Changed to white for better contrast with black background */
        font-size: 1.5rem;
        cursor: pointer;
        z-index: 1001;
    }
    
    #chat-title-static {
        font-size: 1.2rem;
        font-weight: 600;
        display: none; /* Hide the text as we're using the logo instead */
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .chat-container::-webkit-scrollbar { width: 8px; }
    .chat-container::-webkit-scrollbar-track { background: var(--bg-secondary); }
    .chat-container::-webkit-scrollbar-thumb { background-color: var(--accent-primary); border-radius: var(--border-radius); border: 2px solid var(--bg-secondary); }

    .message { max-width: 75%; padding: 0.75rem 1rem; border-radius: var(--border-radius); line-height: 1.5; word-wrap: break-word; position: relative; }
    .user { align-self: flex-end; background-color: var(--accent-primary); color: #FFFFFF; border-bottom-right-radius: 0; }
    .user .chat-content { color: #FFFFFF; }
    .bot { align-self: flex-start; background-color: var(--bg-tertiary); color: var(--text-primary); border-bottom-left-radius: 0; padding-right: 40px; /* Increased padding for menu */ }
    .message .chat-content p:first-child { margin-top: 0; }
    .message .chat-content p:last-child { margin-bottom: 0; }
    .message pre { background-color: #282c34; padding: 1rem; border-radius: var(--border-radius); overflow-x: auto; margin: 0.5rem 0; position: relative; padding-right: 60px; }
    .message code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em; }
    .message .code-copy-btn-container { position: absolute; top: 8px; right: 8px; }
    /* .bot > .reply-actions-container { position: absolute; top: 5px; right: 5px; z-index: 10; display: flex; gap: 5px; } */ /* Removed old container */
    /* .copy-btn, .save-note-btn { background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color); padding: 0.3rem 0.6rem; border-radius: calc(var(--border-radius) / 2); cursor: pointer; font-size: 0.8em; transition: background-color 0.2s, color 0.2s; } */ /* Removed old button styles */
    /* .copy-btn:hover, .save-note-btn:hover { background-color: var(--accent-primary); color: #FFFFFF; } */
    /* .copy-btn:active, .save-note-btn:active { transform: scale(0.95); } */
    /* .bot-reply-copy-btn, .bot-reply-save-btn { padding: 0.2rem 0.4rem; font-size: 0.7em; } */

    /* New Reply Menu Styles */
    .reply-menu-container {
      position: absolute;
      top: 5px;
      right: 5px;
      z-index: 10;
    }
    .reply-menu-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1rem; /* Adjust size as needed */
      padding: 5px;
      border-radius: 50%;
      line-height: 1;
      transition: background-color 0.2s;
    }
    .reply-menu-btn:hover {
      background-color: rgba(0, 0, 0, 0.1);
    }
    .reply-menu-dropdown {
      position: absolute;
      right: 0;
      top: 100%; /* Position below the button */
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 11;
      display: none; /* Hidden by default */
      overflow: hidden;
      min-width: 180px; /* Adjust width as needed */
      margin-top: 4px;
      padding: 4px 0;
    }
    .reply-menu-dropdown.show {
      display: block;
      animation: fadeIn 0.1s ease-out;
    }
    .reply-menu-item {
      padding: 8px 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.9em;
      color: var(--text-primary);
    }
    .reply-menu-item:hover {
      background-color: var(--bg-tertiary);
    }
    .reply-menu-item i {
      width: 16px;
      text-align: center;
      color: var(--text-secondary);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* End New Reply Menu Styles */
    
    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 12px 24px;
      border-radius: 4px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .toast.show {
      opacity: 1;
    }

    /* Input container */
    .input-container {
      display: flex;
      flex-direction: column;
      padding: 1rem 1.5rem;
      background-color: var(--bg-secondary);
      border-top: 1px solid var(--border-color);
      width: 100%;
      position: relative;
      bottom: 0;
      left: 0;
      right: 0;
    }

    /* Input wrapper with position relative for absolute positioning of icons */
    .input-wrapper {
      position: relative;
      background-color: white;
      border-radius: 24px;
      border: 1px solid var(--border-color);
      padding: 8px 16px;
      min-height: 50px; /* Ensure enough height for the input and bottom icons */
      display: flex;
      align-items: center;
    }

    /* User input styling - UPDATED to support up to 10 lines */
    #user-input {
      flex: 1;
      border: none;
      background: transparent;
      padding: 8px 0;
      font-family: var(--font-family);
      font-size: 1rem;
      resize: none;
      outline: none;
      max-height: calc(1.5em * 10); /* UPDATED: Now supports up to 10 lines */
      min-height: calc(1.5em * 2); /* UPDATED: Minimum 2 lines */
      overflow-y: auto;
      margin-bottom: 20px; /* Make space for the bottom icons */
      line-height: 1.5em; /* Explicit line height for calculations */
    }

    /* Right side buttons */
    .input-buttons {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-button {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 1.1rem;
      padding: 8px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
    }

    .input-button:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    #mic-button {
      color: var(--text-secondary);
    }

    #mic-button.recording {
      color: #ff4d4d;
    }

    #send-button {
      color: var(--accent-primary);
    }

    #send-button:disabled {
      color: var(--text-secondary);
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Bottom icons container */
    .bottom-icons {
      position: absolute;
      bottom: 5px;
      left: 16px;
      display: flex;
      gap: 12px;
    }

    .bottom-icon {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.85rem; /* Small icon size */
      padding: 4px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s, transform 0.2s;
    }

    .bottom-icon:hover {
      color: var(--accent-primary);
      transform: scale(1.1);
    }

    /* Active state for To-Do List toggle */
    .bottom-icon.active {
      color: #4CAF50; /* Green color for active state */
      background-color: rgba(76, 175, 80, 0.1); /* Light green background */
    }

    /* Todo List Label Styling - NEW */
    .todo-list-container {
      margin-bottom: 20px;
      font-family: var(--font-family);
    }

    .todo-list-label {
      display: inline-block;
      background-color: #4CAF50; /* Green background color */
      color: white;
      font-size: 14px;
      font-weight: 500;
      padding: 4px 12px;
      border-radius: 16px;
      margin-bottom: 8px;
    }

    .todo-list-content {
      background-color: #f5f5f5;
      border-radius: 8px;
      padding: 16px 20px;
    }

    .todo-list-content h2 {
      margin-top: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .todo-list-content h3 {
      font-size: 16px;
      font-weight: 600;
      margin-top: 16px;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .todo-list-content ul {
      margin-top: 8px;
      margin-bottom: 16px;
      padding-left: 20px;
    }

    .todo-list-content li {
      margin-bottom: 8px;
      line-height: 1.5;
    }
    /* End Todo List Label Styling */

    .loading-indicator { display: none; align-self: flex-start; margin-left: 1.5rem; margin-bottom: 1rem; }
    .loading-indicator span { display: inline-block; width: 8px; height: 8px; margin-right: 4px; border-radius: 50%; background-color: var(--text-secondary); animation: bounce 1.4s infinite ease-in-out both; }
    .loading-indicator span:nth-child(1) { animation-delay: -0.32s; }
    .loading-indicator span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }

    .bot .chat-content table { width: 100%; border-collapse: collapse; margin: 1em 0; font-size: 0.9em; display: block; overflow-x: auto; white-space: nowrap; -webkit-overflow-scrolling: touch}
    .bot .chat-content th, .bot .chat-content td { border: 1px solid var(--border-color); padding: 0.5rem 0.75rem; text-align: left; min-width: 100px; }
    .bot .chat-content th { background-color: var(--bg-tertiary); font-weight: 600; }
    .bot .chat-content ul, .bot .chat-content ol { margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.5rem; }
    .bot .chat-content strong { font-weight: 600; }
    .bot .chat-content a { color: var(--accent-secondary); text-decoration: none; }
    .bot .chat-content a:hover { text-decoration: underline; }

    /* Mobile overlay for sidebar */
    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1005;
    }

    /* Responsive breakpoints - improved for all viewport sizes */
    @media (min-width: 1025px) {
      /* Large desktop */
      .sidebar {
        position: relative;
        left: 0;
      }
      .menu-toggle {
        display: none;
      }
      .header-sidebar-toggle-btn {
        display: block;
      }
      .sidebar-overlay {
        display: none !important;
      }
    }

    @media (max-width: 1024px) {
      /* Medium screens and below - treat like mobile */
      .sidebar {
        position: fixed;
        left: calc(-1 * var(--sidebar-width)); 
        top: 0;
        height: 100%;
        z-index: 1010;
        box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        opacity: 1;
        pointer-events: auto;
        width: 85%; /* Slightly narrower on mobile */
        max-width: var(--sidebar-width);
      }
      
      .sidebar.open {
        left: 0;
      }
      
      .sidebar.open + .sidebar-overlay {
        display: block;
      }
      
      .sidebar.collapsed {
        left: calc(-1 * var(--sidebar-width)); 
        opacity: 0;
        pointer-events: none;
      }
      
      .menu-toggle {
        display: block; 
      }
      
      .header-sidebar-toggle-btn {
        display: none; 
      }
      
      .header-center {
        position: static;
        transform: none;
        flex-grow: 1;
        text-align: center;
      }
      
      header { 
        padding: 0 1rem; 
        justify-content: space-between;
      }
      
      .chat-container, .input-container { 
        padding: 1rem; 
      }
      
      .message { 
        max-width: 90%; 
      }
      
      .bot { 
        padding-right: 30px; 
      }
      
      .message pre { 
        padding-right: 50px; 
      }
      
      #user-input { 
        font-size: 0.95rem; 
      }
      
      /* Adjust logo size for mobile */
      .header-logo {
        height: 35px;
      }

      main {
        height: calc(100vh - var(--header-height) - 120px);
        margin-bottom: 160px; /* Adjusted for input container */
      }

      .input-container {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        padding-bottom: env(safe-area-inset-bottom, 1rem); /* iOS safe area support */
      }
    }

    /* Additional adjustments for very small screens */
    @media (max-width: 480px) {
      .header-center {
        font-size: 1rem;
      }
      
      .message {
        max-width: 95%;
      }
      
      /* Further reduce logo size for very small screens */
      .header-logo {
        height: 30px;
      }
    }
    
    /* Drag and drop styles */
    .drag-area {
      border: 2px dashed var(--border-color);
      border-radius: var(--border-radius);
      padding: 20px;
      text-align: center;
      margin: 10px 0;
      background-color: var(--bg-secondary);
      transition: background-color 0.3s;
    }
    
    .drag-area.active {
      background-color: rgba(21, 67, 206, 0.1);
      border-color: var(--accent-primary);
    }
    
    .drag-area p {
      margin: 0;
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div class="app-container" id="app-container">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>Chat History</h2>
        <button class="sidebar-toggle-btn" id="sidebar-toggle-btn" title="Toggle Sidebar"><i class="fas fa-bars"></i></button>
      </div>
      <button class="new-chat-btn" id="new-chat-btn"><i class="fas fa-plus"></i> New Chat</button>
      <ul class="chat-history-list" id="chat-history-list">
      </ul>
      <!-- Sidebar Navigation Links -->
      <nav class="sidebar-nav">
        <h3>Tools</h3>
        <ul>
          <li><a href="todolist.html"><i class="fas fa-list-check"></i> Todo List</a></li>
          <li><a href="notes.html"><i class="fas fa-sticky-note"></i> My Notes</a></li>
          <li><a href="interviewer.html"><i class="fas fa-user-tie"></i> Mock Interviewer</a></li>
        </ul>
      </nav>
    </aside>
    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <div class="main-content" id="main-content">
      <header>
        <div class="header-left">
          <button class="header-sidebar-toggle-btn" id="header-sidebar-toggle-btn" title="Toggle Sidebar"><i class="fas fa-bars"></i></button>
          <button class="menu-toggle" id="menu-toggle" title="Open Chat History"><i class="fas fa-bars"></i></button>
        </div>
        <div class="header-center">
          <img src="../logos/logoheaderAi.png" alt="Classmate AI Logo" class="header-logo">
          <span id="chat-title-static">CLASSMATE AI</span>
        </div>
        <div class="header-right">
          <!-- Placeholder for future header elements like theme toggle -->
        </div>
      </header>
      <main>
        <div class="chat-container" id="chat-container">
        </div>
        <div class="loading-indicator" id="loading-indicator">
          <span></span><span></span><span></span>
        </div>
      </main>
      <div class="input-container">
        <div class="input-wrapper">
          <textarea id="user-input" placeholder="Ask ClassMate" rows="1"></textarea>
          <div class="input-buttons">
            <button id="mic-button" class="input-button" title="Speak"><i class="fas fa-microphone"></i></button>
            <button id="send-button" class="input-button" title="Send Message"><i class="fas fa-paper-plane"></i></button>
          </div>
          <!-- Bottom icons inside input bar -->
          <div class="bottom-icons">
            <button id="todo-list-option" class="bottom-icon" title="To-Do List"><i class="fas fa-list-check"></i></button>
            <!-- Mock Interviewer option removed -->
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Toast notification element -->
  <div id="toast" class="toast"></div>

  <script>
    const chatContainer = document.getElementById("chat-container");
    const userInput = document.getElementById("user-input");
    const sendButton = document.getElementById("send-button");
    const micButton = document.getElementById("mic-button");
    const loadingIndicator = document.getElementById("loading-indicator");
    const appContainer = document.getElementById("app-container");
    const sidebar = document.getElementById("sidebar");
    const sidebarOverlay = document.getElementById("sidebar-overlay");
    const menuToggle = document.getElementById("menu-toggle"); 
    const sidebarToggleBtn = document.getElementById("sidebar-toggle-btn");
    const headerSidebarToggleBtn = document.getElementById("header-sidebar-toggle-btn");
    const newChatBtn = document.getElementById("new-chat-btn");
    const chatHistoryList = document.getElementById("chat-history-list");
    const mainContent = document.getElementById("main-content");
    const todoListOption = document.getElementById("todo-list-option");
    const serverUrl = "https://classmate1-ffw7.onrender.com"; // Update with your server URL
    const style = document.createElement('style'); // Add CSS for toast messages (can also be in your main CSS file)
    // interviewerOption removed
    const toast = document.getElementById("toast");

    let currentChatId = null;
    let allChats = {}; 
    let recognition = null;
    let isRecording = false;
    let isToDoListModeActive = false;
    let messageBeingSent = false; // Flag to prevent duplicate messages
    let isInitialLoad = true; // Flag to track initial page load
    let resizeTimeout; // For debouncing resize events

    let promptBase = `You are ClassMate, a smart academic assistant for students.
    You help them manage goals, generate to-do lists, explain concepts with code and tables, and reply in an organized, friendly format.
    
    For all queries, respond as a helpful academic assistant.`;

    let todoListPrompt = `IMPORTANT INSTRUCTION: You MUST generate the actual content for a to-do list or plan. Then, format YOUR GENERATED CONTENT according to the following multi-level structure. Fill in all placeholders like [Generated Goal Name] and [Generated Task X.Y] with specific, relevant information based on the user's request. Do not just show an empty template. Your entire response must be:

Goal: [Generated Goal Name based on user query, e.g., Learn Python Basics]
Phase 1: [e.g., Foundational Concepts]
- [Generated Task 1.1, e.g., Understand Python syntax and indentation]
- [Generated Task 1.2, e.g., Learn variables and data types (integers, floats, strings, booleans)]
- [Generated Task 1.3, e.g., Practice with print() and input() functions]
...
Phase 2: [e.g., Data Structures and Control Flow]
- [Generated Task 2.1, e.g., Learn and use lists, tuples, sets, and dictionaries]
- [Generated Task 2.2, e.g., Master string methods and slicing]
- [Generated Task 2.3, e.g., Understand and implement for and while loops]
...
(Add more phases and tasks as appropriate for the user's request)

Remember to break your goals into phases and tasks.`;

    // Function to check if we're in mobile/tablet view
    function isMobileView() {
        // Check if window width is below threshold OR if the window is likely minimized (very small height)
        return window.innerWidth <= 1024 || window.innerHeight < 200; 
    }

    // Sidebar toggle functionality
    function toggleSidebar() {
        const mobileView = isMobileView();
        if (mobileView) {
            // In mobile view, toggle the open class
            sidebar.classList.toggle('open');
            sidebarOverlay.style.display = sidebar.classList.contains('open') ? 'block' : 'none';
            // Ensure desktop classes are removed
            sidebar.classList.remove('collapsed');
            appContainer.classList.remove('sidebar-hidden');
        } else {
            // In desktop view, toggle the collapsed class
            sidebar.classList.toggle('collapsed');
            appContainer.classList.toggle('sidebar-hidden');
            localStorage.setItem('sidebarState_ClassMate', sidebar.classList.contains('collapsed') ? 'collapsed' : 'open');
            // Ensure mobile classes are removed
            sidebar.classList.remove('open');
            sidebarOverlay.style.display = 'none';
        }
        
        // Update toggle button visibility
        updateToggleButtonVisibility();
    }
    
    // Attach click handlers to all toggle buttons
    sidebarToggleBtn.addEventListener('click', toggleSidebar);
    headerSidebarToggleBtn.addEventListener('click', toggleSidebar);
    menuToggle.addEventListener('click', toggleSidebar);

    // Update toggle button visibility based on sidebar state and viewport
    function updateToggleButtonVisibility() {
        const mobileView = isMobileView();
        if (mobileView) {
            // Mobile view
            menuToggle.style.display = 'block';
            headerSidebarToggleBtn.style.display = 'none';
            sidebarToggleBtn.style.display = 'block'; // Ensure internal toggle is visible on mobile
        } else {
            // Desktop view
            menuToggle.style.display = 'none';
            headerSidebarToggleBtn.style.display = sidebar.classList.contains('collapsed') ? 'block' : 'none';
            sidebarToggleBtn.style.display = 'block'; // Ensure internal toggle is visible on desktop
        }
    }

    // Close mobile sidebar when clicking overlay
    sidebarOverlay.addEventListener('click', () => {
        if (sidebar.classList.contains('open')) {
            sidebar.classList.remove('open');
            sidebarOverlay.style.display = 'none';
            updateToggleButtonVisibility();
        }
    });

    // Close mobile sidebar when clicking outside
    document.addEventListener('click', (event) => {
        if (isMobileView() && 
            sidebar.classList.contains('open') && 
            !sidebar.contains(event.target) && 
            !menuToggle.contains(event.target)) {
            sidebar.classList.remove('open');
            sidebarOverlay.style.display = 'none';
            updateToggleButtonVisibility();
        }
    });

    // UPDATED: Dynamic input bar expansion (2 lines default, up to 10 lines, then scroll)
    userInput.addEventListener('input', function() {
        // Reset height to calculate proper scrollHeight
        userInput.style.height = 'auto';
        
        // Get line height from computed style
        const lineHeight = parseFloat(getComputedStyle(userInput).lineHeight) || 24;
        
        // Calculate number of lines (minimum 2, maximum 10)
        const minHeight = lineHeight * 2; // 2 lines minimum
        const maxHeight = lineHeight * 10; // 10 lines maximum
        
        // Set new height based on content
        const newHeight = Math.min(Math.max(userInput.scrollHeight, minHeight), maxHeight);
        userInput.style.height = newHeight + 'px';
        
        // Enable/disable send button based on content
        sendButton.disabled = userInput.value.trim() === '';
    });

    // To-Do List mode toggle with visual feedback
    todoListOption.addEventListener('click', () => {
        isToDoListModeActive = !isToDoListModeActive;
        todoListOption.classList.toggle('active', isToDoListModeActive);
        
        // Show toast notification for mode change
        if (isToDoListModeActive) {
            showToast("To-Do List mode activated! Ask me to create a to-do list.");
        } else {
            showToast("To-Do List mode deactivated.");
        }
    });

    // Show toast notification
    function showToast(message, duration = 3000) {
        toast.textContent = message;
        toast.classList.add('show');
        
        setTimeout(() => {
            toast.classList.remove('show');
        }, duration);
    }

    // Function to check if text contains a to-do list format
    function isToDoListFormat(text) {
        const goalPattern = /goal\s*:/i;
        const hasGoal = goalPattern.test(text);
        const phasePattern = /phase\s*\d+|phase\s*[a-z]+|step\s*\d+|part\s*\d+/i;
        const hasPhase = phasePattern.test(text);
        const taskPattern = /[-â€¢*]\s+\w+|^\d+\.\s+\w+/m;
        const hasTasks = taskPattern.test(text);
        const structurePattern = /goal\s*:.*?(?:phase|step|part)\s*(?:\d+|[a-z]+)/is;
        const hasStructure = structurePattern.test(text);
        return hasGoal && (hasPhase || hasTasks) && hasStructure;
    }

    // Function to save to-do list to localStorage for todolist.html
    function saveToTaskMaster(content) {
        const tasks = JSON.parse(localStorage.getItem("tasks")) || [];
        tasks.push({ 
            text: content, 
            pinned: false,
            highlighted: false
        });
        localStorage.setItem("tasks", JSON.stringify(tasks));
        showToast("To-do list saved successfully!");
    }

    // Script to handle incoming task queries from Task Master
    document.addEventListener('DOMContentLoaded', function() {
        const taskMasterQuery = localStorage.getItem('taskMasterQuery');
        if (taskMasterQuery) {
            userInput.value = taskMasterQuery;
            userInput.dispatchEvent(new Event('input'));
            userInput.focus();
            if (localStorage.getItem('activateTodoMode') === 'true') {
                const todoListOption = document.getElementById('todo-list-option');
                if (todoListOption && !todoListOption.classList.contains('active')) {
                    todoListOption.click();
                }
            }
            localStorage.removeItem('taskMasterQuery');
            localStorage.removeItem('activateTodoMode');
        }
    });

    // Function to copy text to clipboard
    function copyTextToClipboard(text, buttonElement, successIcon, originalIcon) {
        navigator.clipboard.writeText(text).then(() => {
            // Show success feedback
            if (buttonElement) {
                const originalHTML = buttonElement.innerHTML;
                buttonElement.innerHTML = `<i class="fas ${successIcon}"></i>`;
                setTimeout(() => {
                    buttonElement.innerHTML = originalHTML;
                }, 1500);
            }
            showToast("Copied to clipboard!");
        }).catch(err => {
            console.error('Could not copy text: ', err);
            showToast("Failed to copy to clipboard");
        });
    }

    // FIXED: Function to save content to notes - now includes type property
    function saveToNotes(title, content) {
        const notes = JSON.parse(localStorage.getItem("notes")) || [];
        const timestamp = new Date().toISOString();
        notes.push({ 
            id: Date.now().toString(),
            title: title.substring(0, 50), // Limit title length
            content: content,
            created: timestamp,
            updated: timestamp,
            type: "text", // Add type property for compatibility with notes page
            timestamp: timestamp // Add timestamp property for compatibility with notes page
        });
        localStorage.setItem("notes", JSON.stringify(notes));
        showToast("Saved to notes!");
    }

    // Function to render a message in the chat UI
    function renderMessage(text, sender, rawHtml = false) {
        const msgWrapper = document.createElement("div");
        msgWrapper.className = `message ${sender}`;
        
        const chatContentDiv = document.createElement("div");
        chatContentDiv.className = "chat-content";
        
        // UPDATED: Add "To-Do List" label for todo lists
        if (sender === 'bot' && isToDoListFormat(text)) {
            // Create a todo list container with label
            const todoContainer = document.createElement('div');
            todoContainer.className = 'todo-list-container';
            
            // Add the label
            const labelDiv = document.createElement('div');
            labelDiv.className = 'todo-list-label';
            labelDiv.textContent = 'To-Do List';
            todoContainer.appendChild(labelDiv);
            
            // Add the content
            const contentDiv = document.createElement('div');
            contentDiv.className = 'todo-list-content';
            
            if (rawHtml) {
                contentDiv.innerHTML = text;
            } else {
                // Use marked.js to convert markdown to HTML
                contentDiv.innerHTML = marked.parse(text);
            }
            
            todoContainer.appendChild(contentDiv);
            chatContentDiv.appendChild(todoContainer);
        } else {
            // Regular message without todo list formatting
            if (rawHtml) {
                chatContentDiv.innerHTML = text;
            } else {
                // Use marked.js to convert markdown to HTML
                chatContentDiv.innerHTML = marked.parse(text);
            }
        }
        
        // Add syntax highlighting to code blocks
        chatContentDiv.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
            
            // Add copy button to code blocks
            const container = document.createElement('div');
            container.className = 'code-copy-btn-container';
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'input-button';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.title = 'Copy code';
            copyBtn.onclick = function() {
                const code = block.textContent;
                copyTextToClipboard(code, copyBtn, "fa-check", "fa-copy");
            };
            
            container.appendChild(copyBtn);
            block.parentNode.appendChild(container);
        });
        
        // Add menu for bot messages
        if (sender === 'bot') {
            const menuContainer = document.createElement("div");
            menuContainer.className = "reply-menu-container";
            
            const menuBtn = document.createElement("button");
            menuBtn.className = "reply-menu-btn";
            menuBtn.title = "Message options";
            menuBtn.innerHTML = `<i class="fas fa-ellipsis-v"></i>`;

            const menuDropdown = document.createElement("div");
            menuDropdown.className = "reply-menu-dropdown";

            // Add Copy option
            const copyItem = document.createElement("div");
            copyItem.className = "reply-menu-item";
            copyItem.dataset.action = "copy";
            copyItem.innerHTML = `<i class="fas fa-copy"></i> Copy`;
            copyItem.addEventListener("click", () => {
              copyTextToClipboard(text, menuBtn, "fa-check", "fa-ellipsis-v"); // Pass menuBtn for potential feedback icon change
              menuDropdown.classList.remove("show");
            });
            menuDropdown.appendChild(copyItem);

            // Add Save to Notes option
            const saveNoteItem = document.createElement("div");
            saveNoteItem.className = "reply-menu-item";
            saveNoteItem.dataset.action = "save-note";
            saveNoteItem.innerHTML = `<i class="fas fa-bookmark"></i> Save to Notes`;
            saveNoteItem.addEventListener("click", () => {
              let title = "Untitled Note";
              if (currentChatId && allChats[currentChatId] && allChats[currentChatId].messages) {
                const messages = allChats[currentChatId].messages;
                // Find the last user message before this bot message
                for (let i = messages.length - 1; i >= 0; i--) {
                  if (messages[i].role === 'user') {
                    title = messages[i].parts;
                    break;
                  }
                }
              }
              saveToNotes(title, text);
              menuDropdown.classList.remove("show");
            });
            menuDropdown.appendChild(saveNoteItem);

            // Conditionally add Save to To-Do List option
            if (isToDoListFormat(text)) {
              const saveTodoItem = document.createElement("div");
              saveTodoItem.className = "reply-menu-item";
              saveTodoItem.dataset.action = "save-todo";
              saveTodoItem.innerHTML = `<i class="fas fa-list-check"></i> Save to To-Do List`;
              saveTodoItem.addEventListener("click", () => {
                saveToTaskMaster(text); // Use existing function
                menuDropdown.classList.remove("show");
              });
              menuDropdown.appendChild(saveTodoItem);
            }

            // Menu toggle logic
            menuBtn.addEventListener("click", (e) => {
              e.stopPropagation(); // Prevent click from closing menu immediately
              // Close other open menus first
              document.querySelectorAll(".reply-menu-dropdown.show").forEach(openMenu => {
                if (openMenu !== menuDropdown) {
                  openMenu.classList.remove("show");
                }
              });
              menuDropdown.classList.toggle("show");
            });

            menuContainer.appendChild(menuBtn);
            menuContainer.appendChild(menuDropdown);
            msgWrapper.appendChild(menuContainer);
        }

        msgWrapper.appendChild(chatContentDiv);
        chatContainer.appendChild(msgWrapper);
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Function to append a message to the chat history and render it
    function appendMessage(text, sender, rawHtml = false) {
        // Render the message in the UI
        renderMessage(text, sender, rawHtml);
        
        // Save message to current chat
        if (currentChatId) {
            if (!allChats[currentChatId]) {
                allChats[currentChatId] = {
                    id: currentChatId,
                    title: "New Chat",
                    messages: []
                };
            }
            
            allChats[currentChatId].messages.push({
                role: sender === 'user' ? 'user' : 'bot',
                parts: text
            });
            
            // Update chat title if needed
            if (sender === 'user') {
                updateChatTitleIfNeeded(currentChatId, text);
            }
            
            saveChatsToLocalStorage();
            updateChatHistoryUI();
        }
    }

    async function sendMessageAPI(userMessageContent) {
        if (!currentChatId || !allChats[currentChatId]) {
            console.error("sendMessageAPI: No active chat session.");
            appendMessage("Error: No active chat. Please start a new chat.", "bot", true);
            return;
        }
        
        // Don't add to chat history again if already added in sendMessage
        if (!messageBeingSent) {
            allChats[currentChatId].messages.push({ role: "user", parts: userMessageContent });
            updateChatTitleIfNeeded(currentChatId, userMessageContent);
            saveChatsToLocalStorage();
        }

        sendButton.disabled = true;
        micButton.disabled = true;
        loadingIndicator.style.display = 'flex';

        try {
            const conversationHistoryForAPI = allChats[currentChatId].messages.map(m => `${m.role === "user" ? 'User' : 'AI'}: ${m.parts}`).join('\n');
            let fullPrompt = promptBase;
            
            // Add to-do list specific instructions ONLY if the mode is active
            if (isToDoListModeActive) {
                fullPrompt = todoListPrompt;
            }
            
            fullPrompt += `\n\nConversation History:\n${conversationHistoryForAPI}`;
            
            const response = await fetch(serverUrl + "/api/chat", { 
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ prompt: fullPrompt })
            });
            
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            const reply = data.reply || "Sorry, I couldn't get a response.";

            appendMessage(reply, "bot");
            saveChatsToLocalStorage();
        } catch (err) {
            appendMessage(`Error: ${err.message || "Failed to connect to the server."}`, "bot", true);
            console.error("API Error:", err);
        } finally {
            sendButton.disabled = false;
            micButton.disabled = false;
            loadingIndicator.style.display = 'none';
            messageBeingSent = false; // Reset the flag
        }
    }

    function sendMessage() {
        const message = userInput.value.trim();
        if (!message || messageBeingSent) return;
        
        // Set flag to prevent duplicate messages
        messageBeingSent = true;
        
        if (!currentChatId) {
            createNewChat();
        }
        
        appendMessage(message, "user");
        userInput.value = "";
        userInput.style.height = 'auto';
        sendButton.disabled = true;
        
        sendMessageAPI(message);
    }

    sendButton.addEventListener("click", sendMessage);
    userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            if (!sendButton.disabled && !messageBeingSent) {
                sendMessage();
            }
        }
    });

    // Initialize Web Speech API for voice input if available
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            userInput.value = transcript;
            userInput.dispatchEvent(new Event('input'));
        };

        recognition.onstart = () => {
            isRecording = true;
            micButton.classList.add('recording');
            micButton.innerHTML = '<i class="fas fa-microphone" style="color:red"></i>';
            showToast("Listening... Speak now");
        };

        recognition.onend = () => {
            isRecording = false;
            micButton.classList.remove('recording');
            micButton.innerHTML = '<i class="fas fa-microphone"></i>';
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            isRecording = false;
            micButton.classList.remove('recording');
            micButton.innerHTML = '<i class="fas fa-microphone"></i>';
            
            if (event.error === 'not-allowed') {
                showToast("Please enable microphone permissions in browser settings");
            } else if (event.error === 'audio-capture') {
                showToast("Microphone not available or already in use");
            } else {
                showToast("Speech recognition error: " + event.error);
            }
        };

        micButton.addEventListener('click', async () => {
            try {
                if (isRecording) {
                    recognition.stop();
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                setTimeout(() => {// ðŸ” Delay before starting speech recognition (fixes Chrome mobile issue)
                    recognition.start();
                }, 300); // Small delay to ensure stream is ready
                recognition.start();
            } catch (err) {
                console.error('Microphone error:', err);
                if (err.name === 'NotAllowedError') {
                    showToast("Microphone access was denied");
                } else if (err.name === 'NotFoundError') {
                    showToast("No microphone found");
                } else {
                    showToast("Cannot access microphone");
                }
            }
        });
    } else {
        micButton.style.display = 'none';
        showToast("Speech recognition not supported in this browser");
    }

    function createNewChat() {
        const timestamp = Date.now();
        currentChatId = timestamp.toString();
        allChats[currentChatId] = {
            id: currentChatId,
            title: "New Chat",
            messages: []
        };
        
        chatContainer.innerHTML = "";
        saveChatsToLocalStorage();
        updateChatHistoryUI();
        
        // Save current chat ID to localStorage
        localStorage.setItem('currentChatId_ClassMate', currentChatId);
    }

    function updateChatTitleIfNeeded(chatId, userMessage) {
        const chat = allChats[chatId];
        if (chat && chat.title === "New Chat" && userMessage.length > 0) {
            // Use first 30 chars of user message as title, or full message if shorter
            chat.title = userMessage.length > 30 ? userMessage.substring(0, 27) + "..." : userMessage;
        }
    }

    // Function to render all messages for a chat
    function renderChatMessages(chatId) {
        if (!allChats[chatId]) return;
        
        // Clear the chat container
        chatContainer.innerHTML = "";
        
        // Render all messages in the chat
        allChats[chatId].messages.forEach(msg => {
            renderMessage(msg.parts, msg.role === "user" ? "user" : "bot");
        });
    }

    function loadChat(chatId) {
        if (!allChats[chatId]) return;
        
        currentChatId = chatId;
        
        // Render the chat messages without saving them again
        renderChatMessages(chatId);
        
        updateChatHistoryUI();
        
        // Save current chat ID to localStorage
        localStorage.setItem('currentChatId_ClassMate', currentChatId);
    }

    function updateChatHistoryUI() {
        chatHistoryList.innerHTML = '';
        
        // Sort chats by ID (timestamp) in descending order
        const sortedChatIds = Object.keys(allChats).sort((a, b) => parseInt(b) - parseInt(a));
        
        sortedChatIds.forEach(chatId => {
            const chat = allChats[chatId];
            const li = document.createElement('li');
            li.className = chatId === currentChatId ? 'active' : '';
            
            const titleSpan = document.createElement('span');
            titleSpan.className = 'chat-item-title';
            titleSpan.textContent = chat.title;
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'chat-item-actions';
            
            const renameBtn = document.createElement('button');
            renameBtn.className = 'rename-chat-btn';
            renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
            renameBtn.title = 'Rename chat';
            renameBtn.onclick = (e) => {
                e.stopPropagation();
                const newTitle = prompt('Enter new chat title:', chat.title);
                if (newTitle && newTitle.trim()) {
                    chat.title = newTitle.trim();
                    saveChatsToLocalStorage();
                    updateChatHistoryUI();
                }
            };
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-chat-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.title = 'Delete chat';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                if (confirm('Are you sure you want to delete this chat?')) {
                    delete allChats[chatId];
                    saveChatsToLocalStorage();
                    
                    if (chatId === currentChatId) {
                        // If we deleted the current chat, load another one or create new
                        const remainingChatIds = Object.keys(allChats);
                        if (remainingChatIds.length > 0) {
                            loadChat(remainingChatIds[0]);
                        } else {
                            createNewChat();
                        }
                    } else {
                        updateChatHistoryUI();
                    }
                }
            };
            
            actionsDiv.appendChild(renameBtn);
            actionsDiv.appendChild(deleteBtn);
            
            li.appendChild(titleSpan);
            li.appendChild(actionsDiv);
            
            li.addEventListener('click', () => {
                if (chatId !== currentChatId) {
                    loadChat(chatId);
                }
                if (isMobileView()) {
                    toggleSidebar(); // Close sidebar on mobile after selecting chat
                }
            });
            
            chatHistoryList.appendChild(li);
        });
    }

    function saveChatsToLocalStorage() {
        localStorage.setItem('chats_ClassMate', JSON.stringify(allChats));
    }

    // Function to clean up duplicate messages in chat history
    function cleanupChatHistory() {
        // Process each chat
        Object.keys(allChats).forEach(chatId => {
            const chat = allChats[chatId];
            if (!chat.messages || !Array.isArray(chat.messages)) return;
            
            // Create a new array with unique messages
            const uniqueMessages = [];
            const seenMessages = new Set();
            
            chat.messages.forEach(msg => {
                // Create a unique key for each message
                const msgKey = `${msg.role}:${msg.parts}`;
                
                // Only add if we haven't seen this exact message before
                if (!seenMessages.has(msgKey)) {
                    seenMessages.add(msgKey);
                    uniqueMessages.push(msg);
                }
            });
            
            // Replace the messages array with the deduplicated one
            chat.messages = uniqueMessages;
        });
        
        // Save the cleaned up chats
        saveChatsToLocalStorage();
    }

    function loadChatsFromLocalStorage() {
        try {
            const savedChats = localStorage.getItem('chats_ClassMate');
            if (savedChats) {
                allChats = JSON.parse(savedChats);
                
                // Clean up any duplicate messages
                cleanupChatHistory();
                
                // Load last active chat or create new one
                const lastChatId = localStorage.getItem('currentChatId_ClassMate');
                if (lastChatId && allChats[lastChatId]) {
                    loadChat(lastChatId);
                } else if (Object.keys(allChats).length > 0) {
                    // Load most recent chat
                    const mostRecentChatId = Object.keys(allChats)
                        .sort((a, b) => parseInt(b) - parseInt(a))[0];
                    loadChat(mostRecentChatId);
                } else {
                    createNewChat();
                }
            } else {
                createNewChat();
            }
        } catch (err) {
            console.error("Error loading chats:", err);
            createNewChat();
        }
    }

    newChatBtn.addEventListener('click', createNewChat);

    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
        // Load chats from localStorage
        loadChatsFromLocalStorage();
        
        // Initialize sidebar state
        const savedSidebarState = localStorage.getItem('sidebarState_ClassMate');
        if (savedSidebarState === 'collapsed' && !isMobileView()) {
            sidebar.classList.add('collapsed');
            appContainer.classList.add('sidebar-hidden');
        }
        
        // Update toggle button visibility
        updateToggleButtonVisibility();
        
        // Close dropdown menus when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.reply-menu-container')) {
                document.querySelectorAll('.reply-menu-dropdown.show').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            // Debounce resize events
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateToggleButtonVisibility();
                
                // Handle mobile/desktop transitions
                if (isMobileView()) {
                    sidebar.classList.remove('collapsed');
                    appContainer.classList.remove('sidebar-hidden');
                    if (sidebar.classList.contains('open')) {
                        sidebarOverlay.style.display = 'block';
                    }
                } else {
                    sidebar.classList.remove('open');
                    sidebarOverlay.style.display = 'none';
                    
                    // Restore desktop sidebar state from localStorage
                    const savedState = localStorage.getItem('sidebarState_ClassMate');
                    if (savedState === 'collapsed') {
                        sidebar.classList.add('collapsed');
                        appContainer.classList.add('sidebar-hidden');
                    }
                }
            }, 250);
        });
        
        // Focus input field
        userInput.focus();
    });

    // Trigger input event on load to initialize the input field height
    window.addEventListener('load', () => {
        userInput.dispatchEvent(new Event('input'));
        isInitialLoad = false;
    });
  </script>
</body>
</html>
